; until I figure out how the hell (chibi log) works, this will have to do...

(define *access-log* #f)
(define *error-log* #f)

(define (get-access-log-logger)
  *access-log*)

(define (get-error-log-logger)
  *error-log*)

(define (set-access-log-logger! logger)
  (set! *access-log* logger))

(define (set-error-log-logger! logger)
  (set! *error-log* logger))

(define (make-logger file . o)
  ; FIXME: support ports directly
  (let* ((logfd (if (string? file) (open file (bitwise-ior open/write open/append open/create)) #f))
         (logport (if (port? file) file (open-output-file-descriptor logfd)))
         (level 3)
         (next #f))
    (define (log-append logger)
      (if next (next 'append logger) (set! next logger)))
    (define (log-error . o)
      (cond ((>= level 1)
             (apply show logport (make-datestring (current-seconds)) " ERROR " o)
             (show logport nl)
             (log-flush)))
      (if next (apply next 'error o)))
    (define (log-warning . o)
      (cond ((>= level 2)
             (apply show logport (make-datestring (current-seconds)) " WARNING " o)
             (show logport nl)
             (log-flush)))
      (if next (apply next 'warning o)))
    (define (log-info . o)
      (cond ((>= level 3)
             (apply show logport (make-datestring (current-seconds)) " INFO " o)
             (show logport nl)
             (log-flush)))
      (if next (apply next 'info o)))
    (define (log-debug . o)
      (cond ((>= level 4)
             (apply show logport (make-datestring (current-seconds)) " DEBUG " o)
             (show logport nl)
             (log-flush)))
      (if next (apply next 'debug o)))
    (define (log-level) ; no recursion
      level)
    (define (set-log-level! lvl) ; no recursion
      (set! level lvl))
    (define (log-close)
      (close-output-port logport)
      (set! logfd #f)
      (set! logport #f)
      (if next (next 'log-close)))
    (define (log-flush) ; no recursion (internal)
      (flush-output logport))

    (lambda (dispatch . o)
      (cond ((eq? dispatch 'error) (apply log-error o))
            ((eq? dispatch 'info) (apply log-info o))
            ((eq? dispatch 'warning) (apply log-warning o))
            ((eq? dispatch 'debug) (apply log-debug o))
            ((eq? dispatch 'level) (apply log-level o))
            ((eq? dispatch 'set-level!) (apply set-log-level! o))
            ((eq? dispatch 'flush) (apply log-flush o))
            ((eq? dispatch 'append) (apply log-append o))
            ((eq? dispatch 'close) (apply log-close o))
            (else #f)))))


